# -*- coding: utf-8 -*-
"""circle_intersection_over_union.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1t33QRVZ9pTNmv6Jua1c2-XPQxQzTFN7o
"""

import torch

import torch
import math

def intersection_over_union_batch(pred, labels, eps=1e-6):
    """
    Vectorized IoU computation between one circle and multiple circles.

    Args:
        pred (Tensor): Shape [3] → [x, y, r]
        labels (Tensor): Shape [N, 3] → each row is [x, y, r]
        eps (float): Small epsilon for numerical stability.

    Returns:
        Tensor: IoU values, shape [N]
    """
    # Ensure tensor shape
    if pred.ndim == 1:
        pred = pred.unsqueeze(0)  # [1, 3]
    x1, y1, r1 = pred[:, 0], pred[:, 1], pred[:, 2]
    x2, y2, r2 = labels[:, 0], labels[:, 1], labels[:, 2]

    # Ensure all tensors are on same device
    device = labels.device
    x1, y1, r1 = x1.to(device), y1.to(device), r1.to(device)

    # Compute distance between centers
    d = torch.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2 + eps)

    # Area of each circle
    area1 = math.pi * (r1 ** 2)
    area2 = math.pi * (r2 ** 2)

    # Intersection area computation
    r1_sq = r1 ** 2
    r2_sq = r2 ** 2

    # Clamp d to avoid nan in acos
    d_clamped = torch.clamp(d, min=eps)

    # Case 1: No overlap
    no_overlap = d >= (r1 + r2)
    intersection = torch.zeros_like(d, device=device)

    # Case 2: One circle inside the other
    inside = d <= torch.abs(r1 - r2)
    intersection[inside] = math.pi * torch.min(r1, r2)[inside] ** 2

    # Case 3: Partial overlap
    partial = (~no_overlap) & (~inside)
    if partial.any():
        r1_p, r2_p, d_p = r1.expand_as(d)[partial], r2[partial], d[partial]
        acos1 = torch.acos(torch.clamp((r1_p ** 2 + d_p ** 2 - r2_p ** 2) / (2 * r1_p * d_p), -1.0, 1.0))
        acos2 = torch.acos(torch.clamp((r2_p ** 2 + d_p ** 2 - r1_p ** 2) / (2 * r2_p * d_p), -1.0, 1.0))
        part1 = r1_p ** 2 * acos1
        part2 = r2_p ** 2 * acos2
        part3 = 0.5 * torch.sqrt(
            (-d_p + r1_p + r2_p) *
            (d_p + r1_p - r2_p) *
            (d_p - r1_p + r2_p) *
            (d_p + r1_p + r2_p)
        )
        intersection[partial] = part1 + part2 - part3


    # Union area
    union = area1 + area2 - intersection + eps
    iou = intersection / union
    return iou


def intersection_over_union(predictions, labels):
    """
    Args:
        - predictions (tensor): Tensor containing predicted circles in the format (N, 3), where N is the number of
          predictions and each circle is represented by its center coordinates (x, y) and radius (r).
        - labels (tensor): Tensor containing ground truth circles in the same format as predictions.

    Returns:
        - float: IoU value for all examples in the input tensors.

    This function computes the Intersection over Union (IoU) metric for a set of predicted and ground truth circles
    represented by their center coordinates (x, y) and radius (r). In contrast to the standard YOLO function, where
    IoU is calculated for bounding boxes defined by their width and height, here the IoU is computed for circles.

    """
    # Variables and functions
    PI = torch.pi
    logical_and = torch.logical_and
    epsilon = 1e-9
    
    # Max and min for radius and cords
    maxes_r = torch.max(predictions[..., 2:3], labels[..., 2:3])
    mins_r = torch.min(predictions[..., 2:3], labels[..., 2:3])

    # Distance between circle centers
    d = ((predictions[..., 0:1] - labels[..., 0:1]).pow(2) + (predictions[..., 1:2] - labels[..., 1:2]).pow(2)).sqrt() + epsilon

    # Cheking conditions for tensors
    base_condition = logical_and(logical_and(maxes_r > 0, mins_r > 0), d < (maxes_r + mins_r))

    part_condition = logical_and((maxes_r - mins_r) < d, base_condition)

    condition_inside =  logical_and(base_condition, d + mins_r <= maxes_r)

    # Calculate intersection area for condition
    d_pow_2, mins_r_pow_2, maxes_r_pow_2  = d.pow(2), mins_r.pow(2), maxes_r.pow(2), 

    #AuB = torch.where(condition_lens,
    # AuB = torch.where(part_condition,
    #                    mins_r_pow_2 * ((d_pow_2 + mins_r_pow_2 - maxes_r_pow_2) / (2 * d * mins_r)).clamp(min=-1, max=1).acos() +
    #                    maxes_r_pow_2 * ((d_pow_2 + maxes_r_pow_2 - mins_r_pow_2) / (2 * d * maxes_r)).clamp(min=-1, max=1).acos() -
    #                    0.5 * (4*d_pow_2*maxes_r_pow_2 - (d_pow_2 - mins_r_pow_2+maxes_r_pow_2).pow(2)).clamp(min=0).sqrt(),
    #                     torch.zeros_like(d))

    # AuB = torch.where(condition_inside,
    #                   (PI * mins_r_pow_2),
    #                   AuB)

    # AuB = torch.where(torch.isnan(AuB), torch.tensor(0), AuB)
    AuB = torch.where(part_condition,
        mins_r_pow_2 * ((d_pow_2 + mins_r_pow_2 - maxes_r_pow_2) / (2 * d * mins_r)).clamp(min=-1, max=1).acos() +
        maxes_r_pow_2 * ((d_pow_2 + maxes_r_pow_2 - mins_r_pow_2) / (2 * d * maxes_r)).clamp(min=-1, max=1).acos() -
        0.5 * (4 * d_pow_2 * maxes_r_pow_2 - (d_pow_2 - mins_r_pow_2 + maxes_r_pow_2).pow(2)).clamp(min=0).sqrt(),
        torch.zeros_like(d)  # ✅ fix: đúng device
    )

    AuB = torch.where(condition_inside, PI * mins_r_pow_2, AuB)
    AuB = torch.where(torch.isnan(AuB), torch.zeros_like(AuB), AuB)  # ✅ fix: đúng device

    # Calculate output IoU
    #A = maxes_r**2 *PI
    #B = mins_r**2  *PI
    #                 PI   *      (A       +       B)
    return AuB / (PI*(maxes_r_pow_2 + mins_r_pow_2) - AuB)
